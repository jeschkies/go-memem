// Code generated by command: go run asm.go -out bytes.s -stubs bytes.go. DO NOT EDIT.

#include "textflag.h"

// func findInChunk(needle []byte, haystack []byte) int64
// Requires: AVX, AVX2, BMI
TEXT ·findInChunk(SB), NOSPLIT, $0-56
	MOVQ haystack_base+24(FP), AX
	MOVQ needle_len+8(FP), CX
	DECQ CX
	MOVQ needle_base+0(FP), DX

	// create vector filled with first and last character
	MOVQ         DX, BX
	ADDQ         CX, BX
	VPBROADCASTB (DX), Y0
	VPBROADCASTB (BX), Y1
	MOVQ         AX, BX
	ADDQ         CX, BX
	VMOVDQU      (AX), Y2
	VMOVDQU      (BX), Y3
	VPCMPEQB     Y0, Y2, Y0
	VPCMPEQB     Y1, Y3, Y1
	VPAND        Y0, Y1, Y0

	// calculate offsets
	VPMOVMSKB Y0, BX
	MOVQ      $-1, SI

	// loop over offsets, ie bit positions
offsets_loop:
	CMPL   BX, $0x00
	JE     offsets_loop_done
	TZCNTL BX, SI
	MOVQ   AX, DI
	ADDQ   SI, DI

	// test chunk
	// compare two slices
	MOVQ CX, R8
	MOVQ DX, R9

memcmp_loop:
	// the loop is done; the chunks must be equal
	CMPQ R8, $0x00
	JE   memcmp_loop_done
	MOVB (R9), R10
	CMPB (DI), R10
	JNE  memcmp_loop_done
	ADDQ $0x01, DI
	ADDQ $0x01, R9
	DECQ R8
	JMP  memcmp_loop

memcmp_loop_done:
	CMPQ R8, $0x00
	JE   chunk_match
	MOVL BX, SI
	DECL SI
	ANDL SI, BX
	JMP  offsets_loop

offsets_loop_done:
	MOVQ $-1, SI

chunk_match:
	MOVQ SI, ret+48(FP)
	RET

// func Index(haystack []byte, needle []byte) int64
// Requires: AVX, AVX2, BMI
TEXT ·Index(SB), NOSPLIT, $0-56
	MOVQ needle_base+24(FP), AX
	MOVQ needle_len+32(FP), CX
	DECQ CX
	MOVQ haystack_base+0(FP), DX
	MOVQ DX, BX
	ADDQ haystack_len+8(FP), BX
	SUBQ $0x20, BX

	// create vector filled with first and last character
	MOVQ         AX, DI
	ADDQ         CX, DI
	VPBROADCASTB (AX), Y0
	VPBROADCASTB (DI), Y1

chunk_loop:
	CMPQ     DX, BX
	JG       chunk_loop_end
	MOVQ     DX, SI
	ADDQ     CX, SI
	VMOVDQU  (DX), Y2
	VMOVDQU  (SI), Y3
	VPCMPEQB Y0, Y2, Y2
	VPCMPEQB Y1, Y3, Y3
	VPAND    Y2, Y3, Y2

	// calculate offsets
	VPMOVMSKB Y2, DI
	MOVQ      $-1, SI

	// loop over offsets, ie bit positions
offsets_loop:
	CMPL   DI, $0x00
	JE     offsets_loop_done
	TZCNTL DI, SI
	MOVQ   DX, R8
	ADDQ   SI, R8

	// test chunk
	// compare two slices
	MOVQ CX, R9
	MOVQ AX, R10

memcmp_loop:
	// the loop is done; the chunks must be equal
	CMPQ R9, $0x00
	JE   memcmp_loop_done
	MOVB (R10), R11
	CMPB (R8), R11
	JNE  memcmp_loop_done
	ADDQ $0x01, R8
	ADDQ $0x01, R10
	DECQ R9
	JMP  memcmp_loop

memcmp_loop_done:
	CMPQ R9, $0x00
	JE   chunk_match
	MOVL DI, SI
	DECL SI
	ANDL SI, DI
	JMP  offsets_loop

offsets_loop_done:
	MOVQ $-1, SI

chunk_match:
	CMPQ SI, $0x00
	JGE  chunk_loop_end
	ADDQ $0x20, DX
	JMP  chunk_loop

chunk_loop_end:
	MOVQ SI, ret+48(FP)
	RET
